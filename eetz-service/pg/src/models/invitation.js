const { PrismaClient } = require('../generated/prisma');

const { CodedError } = require('./codedError.js');
const prisma = new PrismaClient();

const createInviteError = 'Invitation Operation Failed.';
const findInviteError = 'Invitation Operation Failed.';
const useInviteError = 'Invitation Operation Failed.';

class Invitation {
  constructor(creatorId, inviteEmail) {
    this.createdAt = new Date();
    this.expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days from now
    this.creatorId = creatorId;
    this.inviteEmail = inviteEmail.toLowerCase();
  }
  id;
  code; // Unique code for the invitation, generated by Prisma
  uses = 0; // Default to 0 uses
}

/**
 * Create a new invitation.
 * @param {Object} data - Invitation data
 * @returns {Object} Created invitation object
 */
const createInvitation = async function createInvitation(data) {
  try {
    if (!data.creatorId || !data.inviteEmail) {
      console.error('Missing required fields for creating invitation');
      throw new CodedError({ code: 422, reason: createInviteError });
    }
    const invitation = await prisma.invitation.create({
      data: {
        creatorId: data.creatorId,
        inviteEmail: data.inviteEmail.toLowerCase(),
        expiresAt:
          data.expiresAt || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // Default to 7 days
      },
    });
    if (!invitation) {
      console.error('Failed to create invitation');
      throw new CodedError({ code: 500, reason: createInviteError });
    }
    const storedInvite = await prisma.invitation.findFirst({
      where: { inviteEmail: data.inviteEmail.toLowerCase() },
    });
    if (!storedInvite) {
      console.error('Failed to retrieve created invitation');
      throw new CodedError({ code: 500, reason: findInviteError });
    }
    invitation.code = storedInvite.code;
    return invitation;
  } catch (error) {
    console.error('Error creating invitation:', error);
    throw new CodedError({ code: 500, reason: createInviteError });
  }
};

/**
 * See if we have an invite code for that email that hasn't expired yet.
 * @param {String} inviteCode
 * @param {String} email
 */
const inviteValid = async function (inviteCode, email) {
  const existingInvite = await prisma.invitation.findFirst({
    where: {
      AND: [
        { code: inviteCode },
        { inviteEmail: email.toLowerCase() },
        { expiresAt: { gte: new Date() } },
      ],
    },
  });
  if (!existingInvite) {
    console.error('InviteCode missing or invalid');
    throw new CodedError({ code: 404, reason: findInviteError });
  }
  if (existingInvite.uses >= 1) {
    console.error('InviteCode already used');
    throw new CodedError({ code: 410, reason: findInviteError });
  }
  return existingInvite.code;
};

const useInvite = async function (inviteCode) {
  try {
    const existingInvite = await prisma.invitation.findUnique({
      where: { code: inviteCode },
    });
    if (!existingInvite) {
      console.error('InviteCode missing or invalid');
      throw new CodedError({ code: 404, reason: findInviteError });
    }
    const updatedInvite = await prisma.invitation.update({
      where: { id: existingInvite.id },
      data: { uses: { increment: 1 } },
    });
    if (!updatedInvite) {
      console.error('Failed to update invitation uses');
      throw new CodedError({ code: 500, reason: useInviteError });
    }
    return updatedInvite;
  } catch (error) {
    console.error('Error updating invitation uses:', error);
    throw new CodedError({ code: 500, reason: useInviteError });
  }
};

module.exports = {
  Invitation,
  createInvitation,
  inviteValid,
  useInvite,
};
